[{"content":"starix starix는 github으로 블로그를 만드는사람을 위해 만들어젔으며, commit을 할때 특정 컨벤션을 사용하면 discord로 알림을 보내게 만들어젔다.\nstarix.yml 이걸 그냥 github workflow에 추가해주면된다\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 name: Read Environment Variables and Save to File on: push: branches: - master jobs: build: runs-on: macos-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: download file run: | wget \u0026#34;https://f.5-23.dev/project/starix\u0026#34; chmod +x starix - name: run starix run: | sleep 120 export URI=\u0026#34;${{ secrets.URI }}\u0026#34; ./starix Starix.toml {starix.id}는 블로그 id가 들어가게된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 블로그 url url=\u0026#34;https://blog.5-23.dev/p/{starix.id}/\u0026#34; # 블로그 섬네일 url thumb=\u0026#34;https://blog.5-23.dev/p/{starix.id}/thumb.jpg\u0026#34; # 웹훅 이름 name=\u0026#34;Asta blog\u0026#34; # 웹훅 프로필 avatar=\u0026#34;https://avatars.githubusercontent.com/u/86705803?v=4\u0026#34; [post] # 포스트시 메세지 content=\u0026#34;@everyone `{starix.id}`가 올라왔어요!\u0026#34; # 포스트시 메세지 color=\u0026#34;#2E7EFF\u0026#34; [fix] # 수정시 메세지 content=\u0026#34;\u0026#34; # 수정시 메세지 color=\u0026#34;#FF782E\u0026#34; Secrets 설정 ur-repo \u0026gt; Settings \u0026gt; Secrets and variables \u0026gt; Actions 저 버튼을 누른다. name은 URI, secret은 디스코드 웹훅 url을 쓰면 된다. commmit 해보기 컨밴션 규칙은 간단하다\n블로그 포스트 아래중에 아무거나써도 상관없다.\n1 2 post(id): 내용 upload(id): 내용 블로그 수정 1 fix(id): 내용 결과 포스트커밋과 수정을 둘다하고 찍었습니다 ","date":"2024-06-03T00:00:00Z","image":"https://blog.5-23.dev/p/starix/thumb_hufad68abf6107ffc2ef859ebe1b42b6e2_203216_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/starix/","title":"Starix로 블로그 업로드알림 만들기!"},{"content":"gleam맛보기2 기초 문법 모든 코드에서 main함수와 import gleam/io는 생략한다.\n변수 선언 gleam에서 변수를 선언하는 방법은 Python, Rust와 비슷하고 아주 쉽다.\n1 let 변수명: 타입 = 값 사칙연산(숫자 타입) gleam의 숫자 타입에 관해 알아보자 gleam에는 숫자 타입이 Int와 Float이 있다. python, rust, java, js, c/c++과 같은 언어에서는 Int와 Float은 그냥 소숫정 이후가 존재하는지 아닌지로 나눠저는데, 이 언어는 연산자도 다르다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let a: Int = 3 let b: Int = 4 io.debug(a + b) io.debug(a - b) io.debug(a * b) io.debug(a / b) io.debug(a % b) let a: Float = 3.1 let b: Float = 4.1 io.debug(a +. b) // ━┓ io.debug(a -. b) // ┃ io.debug(a *. b) // ┠─ 연산자 뒤에 \u0026#34;.\u0026#34;이 들어간다. io.debug(a /. b) // ┃ io.debug(a %. b) // ━┛ 문자열 타입 문자열 타입은 String하나를 사용한다 다행히도 Rust처럼 여러개가 있지는 않았다.\n1 2 3 let a: String = \u0026#34;1\u0026#34; let a: String = \u0026#34;1\u0026#34; io.debug(a) 불리언 타입 bool 타입은 True와 False로 나눠저있는 타입이다.\n1 2 let b: Bool = True io.debug(b) 리스트 타입 리스트는 List(T)으로 타입을표기하며 [1, 2, 3]처럼 저장할수 있다\n1 2 let arr: List(T) = [1, 2, 3] io.debug(arr) 튜플타입 튜플은 #(T1, T2, T...)으로 타입을표기하며 #(1, 2, \u0026quot;a\u0026quot;)처럼 저장할수 있다\n1 2 let tup: #(Int, Int, String) = #(1, 2, \u0026#34;a\u0026#34;) io.debug(tup) 다음에 할꺼 다음에는 타입마다 사용할수 있는 기능을 알아볼것이다\n","date":"2024-05-30T00:00:00Z","image":"https://blog.5-23.dev/p/gleam-2/thumb_hu4efc58c8e04c07399d2a263a5f4afac5_112229_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/gleam-2/","title":"gleam언어 맛보기2"},{"content":"nfs가 뭐야? nfs는 클라이언트 컴퓨터의 사용자가 네트워크 상의 파일을 직접 연결된 스토리지에 접근하는 방식과으로 접근하도록 도와준다. udp와 tcp통신을 둘다 지원하며, 인터넷 속도가 느리다면 udp로 빠르다면 tcp로 연결하여 사용하면 된다.\n설치하기 arch\n1 yay -S nfs-utils debian\n1 sudo apt install nfs-kernel-server 서버설정 위 명령어를 썼으면 아마 /etc/exports파일이 만들어젔을 것이다. 이제 저 파일을 열어서 수정해보자\n1 여는걸/허용할/폴더 허용할/ip들(권한,sync,insecure,all_squash,no_subtree_check,anonuid=유저id,anongid=그룹id) 만약 모든 ip를 허용하고싶다는 *을 쓰면 된다.\nuid, gid구하기 1 2 $ id username uid=1000(username) gid=1000(username) groups=1000(username),3(sys),998(wheel),981(rfkill) 이 명령어를 써서 uid와 gid가 1000임을 알수 있다.\n설정파일 예시 아레는 내 설정파일이다 /home/realsus/files는 내가 열기를 허용할 파일을 의미하고 rw는 읽기(read) 쓰기(write)권한을 의미한다. 내ip와 서버컴퓨터가 직접 접속할수 있는걸 원하니 내ip/서버ip를 써서 허용해줬고 나의 uid, gid는 1000이니 그렇게 써준다.\n1 /home/realsus/files 192.192.192.192/0.0.0.0(rw,sync,insecure,all_squash,no_subtree_check,anonuid=1000,anongid=1000) 서버 실행 exportfs를 사용하여 아까 설정한 파일을 적용시켜주고 systemctl을 사용하여 nfs서버를 실행시켜준다.\n1 2 sudo exportfs -a sudo systemctl enable --now nfs-server.service 클라이언트에서 연결 나는 macos를 사용중이니 mac에서 연결하는방법만 쓰겠다. 다른os에서 연결하는방법은 다른사람들의 블로그를 참고하기 바란다.\n폴더 만들기 먼저 mkdir을 사용해 연결(mount)할 폴더를 만들어준다.\n1 mkdir myServer 연결(mount)하기 1 sudo mount -t nfs -o resvport,권한,noowners,vers=서버-버전 ip:/아까/설정에서/허용한/파일/주소 ./연결(mount)할/폴더/경로 예시는 다음과 같다. 나는 rw수정밑 읽기 권한을 허용했고 tcp로 연결했다 내 ip가 있는 도매인을 써줬고 다음으로는 내가 허용한 폴더의 경로를 써줬다. 만약 udp로 연결하고 싶다면 vers를 4가 아니라 3으로 바꿔주면 된다.\n1 sudo mount -t nfs -o resvport,rw,noowners,vers=4 내-서버ip:/home/realsus/files /Users/realsus/myServer 연결해제(umount)하기 umount하는 방법은 연결하는것과 다르게 매우 쉽다.\n1 sudo umount /아까/연결(mount)한/폴더/경로 나는 아레와 같이 써줬다\n1 sudo umount /Users/realsus/myServer 쉽게 연결할수있는 쉘파일 작성 나는 연결이 끊길때마다 다시명령어를 쓰는게 귀찮아서 아레와 같은 쉘 코드를 만들어놨다.\n1 2 3 4 5 #!/bin/bash MOUNT_PATH=\u0026#34;/Users/realsus/Server\u0026#34; echo $MOUNT_PATH sudo umount $MOUNT_PATH sudo mount -t nfs -o resvport,rw,noowners,vers=4 내-서버ip:/home/realsus/files $MOUNT_PATH ","date":"2024-05-24T00:00:00Z","image":"https://blog.5-23.dev/p/nfs/thumb_hucb85ee61a88800d537b4546288d79188_47941_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/nfs/","title":"2024 nfs로 빠르게 서버파일 관리하기"},{"content":"규칙 Game of Life은 간단한 2가지의 규칙으로 돌아간다.\n죽은 칸에 접한 8칸 중 정확히 3칸에 세포가 살아 있다면 해당 칸의 세포는 그 다음 세대에 살아난다. 살아있는 칸과 접한 8칸 중 2칸미만 또는 3칸초과의 세포가 살아 있다면 해당 칸의 세포는 죽는다. 1번 사진은 중항을 기준으로 근처에 3칸의 살아있는 세포가 있으니 살아난다. 2번 사진은 중항을 기준으로 근처에 2칸 미만 또는 3칸 초과의 살아있는칸이 있으니 세포가 죽는다. 알고리즘 생각하기 죽어있는 세포와 살아있는 세포의 위치를 모두 배열에 넣는다. 살아있는 세포의 위치 인덱스만을 모아놓은 배열을 만들어 구현한다. 이런식으로 2가지방법이 있다.\n1번 방법의 경우 구현하기는 2번보다 쉽지만 맵을 크게 만들기에는좀 무리가 있다. 2번 방법의 경우에는 구현하기가 좀 어렵지만 맵을 크게구현해도 세포의 살아있는칸의 위치만 기억하니 용량도 적고 최적화도 잘된다.(그리고 맵을 무한하게도 만들수 있다) 프로젝트 초기화하기 이제 프로젝트를 초기화해보자\n명령어 1 2 3 cargo install wasm-pack wasm-pack new game-of-life cd life-of-game src \u0026gt; lib.rs 1 2 mod utils; use wasm_bindgen::prelude::*; Cargo.toml Cargo.toml은 이렇게바꿔준다\n프로그래밍 시작 이제 Game of Life을 만들어보자\nenum, struct만들기 enum을 통해서 세포의 상태를 만드는 이유는 세포의 상태를 직관적으로 상태를 볼 수 있기 때문에 사용한다\n1 2 3 4 5 6 #[wasm_bindgen] // wasm으로 빌드하기위해 wasm_bindgen매크로를 써준다. #[derive(Clone, Copy, Debug, PartialEq, Eq)] // 나중에 비교, 복사, 출력 등을 할수있으니 추가해준다 pub enum Cell { Dead, Alive, } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #[wasm_bindgen] pub struct LifeOfGame { alives: Vec\u0026lt;(isize, isize)\u0026gt;, // 살아있는 세포의 위치 camera: (isize, isize), // 카메라의 위치(렌더링할떄 일정 부분만 보이게 하기위해 넣는다) } #[wasm_bindgen] impl LifeOfGame { // 그냥 평범한 초기화 코드 pub fn new() -\u0026gt; Self { Self { alives: vec![], camera: (0, 0), } } } 세포 삽입/삭제 구현 alives배열을 쉽게 관리하기위해 set메서드를 만든다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #[wasm_bindgen] impl LifeOfGame { // ..생략 fn set(\u0026amp;mut self, i: isize, j: isize, state: Cell) { if state == Cell::Dead { // (i, j)에 살아있는 세포가 없으면 이미 죽어있는거니 굳이 안죽인다 if self.alives.contains(\u0026amp;(i, j)) { self.alives.remove( // (i, j)에 위치한 살아있는 세포의 인덱스를 가저옴 self.alives .iter() .enumerate() .find(|x| x.1 == \u0026amp;(i, j)) .unwrap() .0, ); } } else { // (i, j)에 살아있는 세포가 있음면 이미 살아있는거니 추가하지 않는다 if !self.alives.contains(\u0026amp;(i, j)) { self.alives.push((i, j)); } } } } 세포 값 변경하기 아까만든 set메서드를 활용해서 값을 반전시키는 메서드를 만든다.\n1 2 3 4 5 6 7 8 9 10 11 #[wasm_bindgen] impl LifeOfGame { // ..생략 pub fn toggle(\u0026amp;mut self, i: isize, j: isize) { if self.alives.contains(\u0026amp;(i, j)) { self.set(i, j, Cell::Dead) } else { self.set(i, j, Cell::Alive) } } } 다음값 확인하기 #규칙에 있는걸 확인하여 1번 실행하는 step메서드를 만들어준다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #[wasm_bindgen] impl LifeOfGame { // ..생략 pub fn step(\u0026amp;mut self) { // 한번에 바꾸지 않고 조금씩 바꾸면 문제가 생길수있으니 백터를 만들어 해결행다 let mut changes = vec![]; // 규칙에서 살아있는 세포의 위치만 확인하니 반복문에 넣어서 돌린다. for alive in \u0026amp;self.alives { let mut count = 0; // 살아있는 세포에 이웃한 인덱스를 받아오기위해 -1부터 1까지 반복문에 넣는다 for i in -1..=1 { for j in -1..=1 { // 자신을 제외하고 카운트한다 if i == 0 \u0026amp;\u0026amp; j == 0 { continue; } let x = alive.0 as i32 + i; let y = alive.1 as i32 + j; { let mut count = 0; // 변수를 가릴수 있는걸 이용하여 변수를 만들어준다 // 위 반복문가 같은이유로 이런식으로 돌린다 for k in -1..=1 { for l in -1..=1 { let xx = x + k; let yy = y + l; count += self.alives.contains(\u0026amp;(xx as isize, yy as isize)) as i32; } } // 살아있는세포가 3개면 새로운 세포가 태어난다 if count == 3 { changes.push((x as isize, y as isize, Cell::Alive)); } } count += self.alives.contains(\u0026amp;(x as isize, y as isize)) as i32; } } // 살아있는세포가 2보다 작거나 3보다 크면 죽는다 if 2 \u0026gt; count || count \u0026gt; 3 { changes.push((alive.0, alive.1, Cell::Dead)); } } // 위에서 변경한다고 해준값을 반복문을통해 변경해준다 for data in \u0026amp;changes { self.set(data.0, data.1, data.2) } } } 그리기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #[wasm_bindgen] impl LifeOfGame { // 자신이 보고있는부분을움직아는 메서드 pub fn move_camera(\u0026amp;mut self, x: isize, y: isize) { self.camera.0 += x; self.camera.1 += y; } pub fn draw(\u0026amp;self, width: isize, height: isize) { let doc = web_sys::window().unwrap().document().unwrap(); // js의 document와 같은 객채를 가저옴 let game = doc.get_element_by_id(\u0026#34;game\u0026#34;).unwrap(); // game이라는 id를 가진값을 가저옴 let mut html = String::new(); // id가 {i},{j}인 타일들을 그림 for i in self.camera.1..(height + self.camera.1) { html.push_str(\u0026#34;\u0026lt;div\u0026gt;\u0026#34;); for j in self.camera.0..(width + self.camera.0) { html.push_str(\u0026amp;format!( \u0026#34;\u0026lt;div type=\u0026#39;button\u0026#39; id=\u0026#39;{i},{j}\u0026#39; class=\u0026#39;tile\u0026#39; {}\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;, if self.alives.contains(\u0026amp;(i as isize, j as isize)) { \u0026#34;alive\u0026#34; // 살아있을경우 alive attr을 추가해서 놔둠 } else { \u0026#34;\u0026#34; } )); } html.push_str(\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;); } game.set_inner_html(\u0026amp;html); } } 빌드하기 이제 wasm의 코드를 다 만들었으니 이 코드를 빌드해보자 아레 코드를쓰면 웹에서 쓸수있는 wasm이 pkgs폴더에 빌드될거다.\n1 wasm-pack build --target web html 코드 작성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta notsus=\u0026#34;i use nixos btw\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;START\u0026#34; id=\u0026#34;puse\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; --\u0026gt; \u0026lt;main id=\u0026#34;game\u0026#34;\u0026gt;a\u0026lt;/main\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import init, { LifeOfGame } from \u0026#39;./pkg/wasm_pack_pra.js\u0026#39; await init() // 초기화 alert(\u0026#34;move: arrow key\\npuse: space\u0026#34;); let game = LifeOfGame.new(); // 아까만든 게임객채 가저오기 draw(); let PUSE = 1; let SPEED = 100; function toggle(i, j) { game.toggle(i, j); } function draw() { game.draw(window.innerWidth / 20, window.innerHeight / 20); document.querySelectorAll(\u0026#34;div.tile\u0026#34;).forEach((button) =\u0026gt; { if (button.id.indexOf(\u0026#34;,\u0026#34;) != -1) { // 클릭했을때 세포 반전시키기 button.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { let [i, j] = button.id.split(\u0026#34;,\u0026#34;).map(Number); toggle(i, j); draw(); }); } }) } // 카메라 움직이기 window.onkeydown = (e) =\u0026gt; { if (e.key == \u0026#34;ArrowRight\u0026#34;) { game.move_camera(1, 0); draw(); } if (e.key == \u0026#34;ArrowLeft\u0026#34;) { game.move_camera(-1, 0); draw(); } if (e.key == \u0026#34;ArrowDown\u0026#34;) { game.move_camera(0, 1); draw(); } if (e.key == \u0026#34;ArrowUp\u0026#34;) { game.move_camera(0, -1); draw(); } if (e.key == \u0026#34; \u0026#34;) { PUSE = !PUSE; } console.log(e.key) } setInterval(() =\u0026gt; { // 멈추지 않았을때 한번씩 실행시키기 if (!PUSE) { game.step(); draw(); } }, 100); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; * { background-color: #282828; margin: 0; padding: 0; } body { overflow: hidden; } main { display: flex; flex-direction: column; } div { display: flex; } div.tile { border: solid #ffffff28 0.5px; width: 20px !important; height: 20px; /* background-color: red; */ width: fit-content; \u0026amp;[alive] { background-color: #fff; } } \u0026lt;/style\u0026gt; 결과 완성하면 다음과 같은 결과가 나온다 코드 결과 ","date":"2024-04-17T00:00:00Z","image":"https://blog.5-23.dev/p/log/thumb_hucb85ee61a88800d537b4546288d79188_208716_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/log/","title":"Game of Life 만들기"},{"content":"번들에 컴포넌트 삽입하기 번들을 삽입하려면 스폰을 한후 .insert(컴포넌트)를 사용하여 삽입을 할수 있다\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #[derive(Component)] struct MyCustomComponent { name: String, } fn setup(mut commands: Commands) { // ..생략 commands .spawn(SpriteBundle { sprite: Sprite { custom_size: Some(Vec2::new(100.0, 100.0)), // 크기 설정 ..Default::default() }, transform: Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)), // 기본위치 설정 ..Default::default() }) // sprite번들에 MyCustomComponent 컴포넌트를 추가해서 특정 정보를 저장 .insert(MyCustomComponent { name: \u0026#34;aaa\u0026#34;.to_string(), }); commands .spawn(SpriteBundle { sprite: Sprite { custom_size: Some(Vec2::new(100.0, 100.0)), ..Default::default() }, transform: Transform::from_translation(Vec3::new(-150.0, -100.0, 0.0)), ..Default::default() }) .insert(MyCustomComponent { name: \u0026#34;bbb\u0026#34;.to_string(), }); } 번들 값 수정하기 번들의 값을 가저오거나 수정하기 위해서는 Query문을 자세히 알아야한다. 기본적으로 Query문은 Query\u0026lt;(\u0026amp;가, \u0026amp;mut 저, mut 오, 려, \u0026amp;는, \u0026amp;mut 값), With\u0026lt;컴포넌트\u0026gt;\u0026gt; 이런식의 타입을 가지고 있고 가저오려는 값에는 다음과 같은 값이 들어갈수 있다(비교적 많이쓰는것만 써저있어 다른것도 들어갈수있다)\n이름/반환타입 설명 Transfrom 위치값을 변경할수있는 값을 반환한다 * Style nodebunddle종류의 번들의 스타일을 변경 가능하다 Entity 나중에 번들을 디스폰 할때 사용된다 * BackgroundColor nodebunddle종류의 번들의 스타일을 변경 가능하다 컴포넌트(자기자신) 자신의 값을 얻어올수있다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn main() { App::new() // ...생략 .add_systems(Update, component_move) // 계속 실행되는 시스템 .run(); } fn component_move( // 지금 생성되있는 모든 MyCustomComponent 컴포넌트의 정보를 가져옴 // 수정해야해서 mut q로 받는다 mut q: Query\u0026lt;(\u0026amp;mut Transform, \u0026amp;MyCustomComponent, \u0026amp;Style), With\u0026lt;MyCustomComponent\u0026gt;\u0026gt;, ) { // 소환한 모든 컴포넌트를 반복문을 사용하여 출력 for (mut transform, custome_comp, e) in \u0026amp;mut q { // 아까 생성한 컴포넌트의 이름을 출력 transform.translation.x += 1.; println!( \u0026#34;{}: {:?}\u0026#34;, custome_comp.name, (transform.translation.x, transform.translation.y) ); } } ","date":"2024-04-12T00:00:00Z","image":"https://blog.5-23.dev/p/zero2bevy-4/thumb_hufad68abf6107ffc2ef859ebe1b42b6e2_84202_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/zero2bevy-4/","title":"Zero부터 시작하는 bevy - 4"},{"content":"컴포넌트 만들기 화면에 있는 모든 객채를 검사하면 안되니 컴포넌트라는것을 만들어 하나씩 검사해보자. 나는 MyCustomComponent라는 이름으로 만들었는데 이름은 바꿔도 상관없다\n1 2 3 4 #[derive(Component)] struct MyCustomComponent { // 이름은 바꿔도 상관없음 name: String, } 컴포넌트 생성 아까 우리가 만들었던 컴포넌트를 생성해보자\n1 2 3 4 5 6 7 8 9 10 11 12 fn setup(mut commands: Commands) { commands.spawn(Camera2dBundle::default()); // aaa라는 이름으로 MyCustomComponent생성 commands.spawn(MyCustomComponent { name: \u0026#34;aaa\u0026#34;.to_string(), }); // bbb라는 이름으로 MyCustomComponent생성 commands.spawn(MyCustomComponent { name: \u0026#34;bbb\u0026#34;.to_string(), }); } 이벤트 만들기 컴포넌트까지 생성했으니 이제 이벤트를 만들어보자\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { App::new() // ...생략 .add_systems(Update, component_info) // Update시스템: 계속 반복되면서 실행되게 해줌 .run(); } fn component_info( // 지금 생성되있는 모든 MyCustomComponent 컴포넌트의 정보를 가져옴 q: Query\u0026lt;\u0026amp;MyCustomComponent\u0026gt;, ) { // 소환한 모든 컴포넌트를 반복문을 사용하여 출력 for component in q.iter() { // 아까 생성한 컴포넌트의 이름을 출력 println!(\u0026#34;name: {}\u0026#34;, component.name); } } ","date":"2024-04-10T00:00:00Z","image":"https://blog.5-23.dev/p/zero2bevy-3/thumb_hufad68abf6107ffc2ef859ebe1b42b6e2_84202_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/zero2bevy-3/","title":"Zero부터 시작하는 bevy - 3"},{"content":"설정 배경을 없에기 위해 main함수에 이 옵션을 추가해줘야한다\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 App::new() .insert_resource(ClearColor(Color::rgba(0.0, 0.0, 0.0, 0.0))) // 투명배경 .add_plugins(DefaultPlugins.set(WindowPlugin { primary_window: Some(Window { title: \u0026#34;Bevy game\u0026#34;.to_string(), // 제목 canvas: Some(\u0026#34;#bevy\u0026#34;.to_owned()), prevent_default_event_handling: false, transparent: true, decorations: false, #[cfg(target_os = \u0026#34;macos\u0026#34;)] composite_alpha_mode: CompositeAlphaMode::PostMultiplied, // 맥에서 배경 없엠 window_level: bevy::window::WindowLevel::AlwaysOnTop, ..default() }), ..default() })) 없는곳 클릭설정 1 2 3 4 5 6 7 8 9 10 11 fn update_cursor_hit_test( click: Res\u0026lt;ButtonInput\u0026lt;MouseButton\u0026gt;\u0026gt;, cursor_world_pos: Res\u0026lt;CursorWorldPos\u0026gt;, mut q_primary_window: Query\u0026lt;\u0026amp;mut Window, With\u0026lt;PrimaryWindow\u0026gt;\u0026gt;, mut q_pet: Query\u0026lt;(\u0026amp;mut Pet, \u0026amp;Transform), With\u0026lt;Pet\u0026gt;\u0026gt;, ) { let mut primary_window = q_primary_window.single_mut(); // If the window has decorations (e.g. a border) then it should be clickable primary_window.cursor.hit_test = true; // 이 값이 바뀔떄 배경 클릭 여부가 결정된다. } 응용코드 ","date":"2024-03-24T00:00:00Z","image":"https://blog.5-23.dev/p/zero2bevy-2.5/thumb_hufad68abf6107ffc2ef859ebe1b42b6e2_84202_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/zero2bevy-2.5/","title":"Zero부터 시작하는 bevy - 특별편?"},{"content":"gleam맛보기 gleam은 erlang환경에서 돌아가는 언어다(elixir처럼)\ngleam install window 1 scoop install gleam mac 1 brew install gleam linux 1 nix profile install gleam 초기화 name이라는 폴더에 gleam프로젝트가 만들어진다\n1 gleam new \u0026lt;name\u0026gt; 이제 실행을 해봐야한다. 이 명령어를 쓰면 hello for 이 출력될꺼다.\n1 2 cd \u0026lt;아까 쓴 name\u0026gt; gleam run ","date":"2024-03-16T00:00:00Z","image":"https://blog.5-23.dev/p/gleam-1/thumb_hu4efc58c8e04c07399d2a263a5f4afac5_112229_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/gleam-1/","title":"gleam언어 맛보기"},{"content":"번들 번들은 commands.spawn을 통해 소환할수 있고, 종류가 좀 많다. 그러니 우리는 몇개만 알아보자\nNodeBundle NodeBundle은 간단하게 화면에 사각형을 띄우기에 좋다.\nNodeBundle은 다음과 같은 값이 들어간다 (많이 쓰이는것만 주석을 달아놨다)\n1 2 3 4 5 6 7 8 9 10 11 12 13 pub struct NodeBundle { pub node: Node, pub style: Style, // 위치, 크기같은 스타일을 설정할수 있다 pub background_color: BackgroundColor, // 배경색을 설정할수 있다 pub border_color: BorderColor, // 아웃라인 색상을 설정할수 있다 pub focus_policy: FocusPolicy, pub transform: Transform, // 기본 정보에서 값을 추가하여 조정한다 pub global_transform: GlobalTransform, pub visibility: Visibility, // 보이는지 안보이는지를 설정할수 있다 pub inherited_visibility: InheritedVisibility, pub view_visibility: ViewVisibility, pub z_index: ZIndex, // 번들이 겹첬을때 보이는 우선순위를 설정한다 } 예시 사용법은 다음과 같다\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 fn startup( // 엔티티를 스폰하기 위해서 commands를 추가해준다 mut commands: Commands, ) { // commands.sapwn는 엔티티/번들 을 스폰하는 메서드이다 commands.spawn( // 2d카메라를 기본 형식으로 스폰한다 Camera2dBundle::default(), ); commands.spawn(NodeBundle { style: Style { // 크기를 100px로 설정한다 width: Val::Px(100.0), height: Val::Px(100.0), // 위치를 위로부터100px, 왼쪽으로부터100px로 설정한다 top: Val::Px(100.0), left: Val::Px(100.0), ..Default::default() }, //배경색을 흰색으로 설정한다 background_color: BackgroundColor(Color::hex(\u0026#34;#ffffff\u0026#34;).unwrap()), ..Default::default() }); } ImageBundle 만약 NodeBunddle에 사진을 넣고싶다면 이걸 쓰면 된다. 여기에서는 NodeBunddle과 다르게 사진을 추가할수있는 image속성과 사진의 크기를 조정할수있는 image_size가 추가로 있다\n세팅 일단 이미지를 불러와야해서 assets폴더를 만들어주고 아무 사진이나 assets폴더에 넣는다 경로는 이렇다\n1 2 3 4 5 6 7 assets/ - test.png // 나는 귀여운 ferris사진을 test.png라는 이름으로 넣었다 src/ - main.rs Cargo.lock Cargo.toml 예시 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 fn startup( // 엔티티를 스폰하기 위해서 commands를 추가해준다 mut commands: Commands, // assets폴더를 로드하기 위해서 AssetServer를 추가해준다 assets_server: Res\u0026lt;AssetServer\u0026gt;, ) { // commands.sapwn는 엔티티/번들 을 스폰하는 메서드이다 commands.spawn( // 2d카메라를 기본 형식으로 스폰한다 Camera2dBundle::default(), ); commands.spawn(ImageBundle { style: Style { // 크기를 100px로 설정한다 width: Val::Px(100.0), height: Val::Px(100.0), // 위치를 위로부터100px, 왼쪽으로부터100px로 설정한다 top: Val::Px(100.0), left: Val::Px(100.0), ..Default::default() }, // assets폴더에서 test.png를 로드한다 image: assets_server.load(\u0026#34;test.png\u0026#34;).into(), //배경색을 흰색으로 설정한다 ..Default::default() }); } SpriteBunddle SpriteBunddle은 기본적으로 중항에 정렬된다는 특징이 있다 ui를 만드는게 아니라면 이걸 쓰면 된다.\n1 2 3 4 5 6 7 8 9 pub struct SpriteBundle { pub sprite: Sprite, // 스프라이트의 크기, 위치, 색상등을 조정할수 있다. pub transform: Transform, pub global_transform: GlobalTransform, pub texture: Handle\u0026lt;Image\u0026gt;, pub visibility: Visibility, pub inherited_visibility: InheritedVisibility, pub view_visibility: ViewVisibility, } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fn startup( // 엔티티를 스폰하기 위해서 commands를 추가해준다 mut commands: Commands, // assets폴더를 로드하기 위해서 AssetServer를 추가해준다 assets_server: Res\u0026lt;AssetServer\u0026gt;, ) { // commands.sapwn는 엔티티/번들 을 스폰하는 메서드이다 commands.spawn( // 2d카메라를 기본 형식으로 스폰한다 Camera2dBundle::default(), ); commands.spawn(SpriteBundle { // assets폴더에서 test.png를 로드한다 (여기선 .into는 굳이 안써도 됨) texture: assets_server.load(\u0026#34;test.png\u0026#34;), //배경색을 흰색으로 설정한다 ..Default::default() }); } 심화 예시\n","date":"2024-03-16T00:00:00Z","image":"https://blog.5-23.dev/p/zero2bevy-2/thumb_hufad68abf6107ffc2ef859ebe1b42b6e2_84202_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/zero2bevy-2/","title":"Zero부터 시작하는 bevy - 2"},{"content":"카메라 설정하기 화면을 보이게 하기 위해서는 카메라를 스폰해줘야한다.\n1 2 3 4 5 6 7 8 9 10 11 fn startup( // 엔티티를 스폰하기 위해서 commands를 추가해준다 mut commands: Commands ) { // commands.sapwn는 엔티티/번들 을 스폰하는 메서드이다 commands.spawn( // 2d카메라를 기본 형식으로 스폰한다 Camera2dBundle::default() ); } 실행하면 배경이 검정 -\u0026gt; 회색으로 바껴있을꺼다 배경 변경 배경을 변경하는 방법은 2개가 있다\nmain함수에서 변경 함수에 있는 commands를 사용하여 변경 main함수에서 변경 1 2 3 4 5 6 7 fn main() { App::new() .add_plugins(bevy::DefaultPlugins) .insert_resource(ClearColor(Color::hex(\u0026#34;#8aadf4\u0026#34;).unwrap())) // cLearColor라는것을 insert_resource를 사용하여 추가하면 배경색이 바뀐다 .add_systems(Startup, startup) .run(); } setup함수에서 변경 setup을 불러오는데 시간이 좀 걸리기때문에 이 방법은 처음 배경을 초기화 할때는 추천하지 않는다\n1 2 3 4 5 6 7 8 9 10 11 12 fn startup( // 엔티티를 스폰하기 위해서 commands를 추가해준다 mut commands: Commands, ) { // commands.sapwn는 엔티티/번들 을 스폰하는 메서드이다 commands.spawn( // 2d카메라를 기본 형식으로 스폰한다 Camera2dBundle::default(), ); // 배경색상 설정 commands.insert_resource(ClearColor(Color::hex(\u0026#34;#8aadf4\u0026#34;).unwrap())) } ","date":"2024-03-15T00:00:00Z","image":"https://blog.5-23.dev/p/zero2bevy-1/thumb_hufad68abf6107ffc2ef859ebe1b42b6e2_84202_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/zero2bevy-1/","title":"Zero부터 시작하는 bevy - 1"},{"content":"베비 설치 1 2 3 cargo new zero2bevy cd zero2bevy cargo add bevy 설치가 완료됐으면 다음과 같은 코드를 작성하여 실행해보자. 설치가 정상적으로 됐으면 오류가 없이 실행될꺼다.\n1 2 3 4 use bevy::prelude::*; fn main() { App::new().run(); } 실행 이벤트 감지 베비는 add_systems(Startup, 함수)를 사용하여 실행 이벤트를 감시할수 있다\n1 2 3 4 5 6 7 8 9 use bevy::prelude::*; fn main() { App::new() .add_systems(Startup, startup) // 아레 지정할 startup함수를 베비가 실행됬을때 실행한다 .run(); } fn startup() { println!(\u0026#34;Hello, Bevy!\u0026#34;); } 화면 띄우기 화면을 띄우기 위해서는 plugin을 설정해줘야한다 bevy에서 plugin을 설정하고 싶다면 add_plugin메서드를 사용하면 된다\n1 2 3 4 5 6 7 8 9 10 use bevy::prelude::*; fn main() { App::new() .add_plugins(bevy::DefaultPlugins) // 기본 베비 플러그인 설정 .add_systems(Startup, startup) .run(); } fn startup() { println!(\u0026#34;Hello, Bevy!\u0026#34;); } ","date":"2024-03-14T00:00:00Z","image":"https://blog.5-23.dev/p/zero2bevy-0/thumb_hufad68abf6107ffc2ef859ebe1b42b6e2_84202_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/zero2bevy-0/","title":"Zero부터 시작하는 bevy - 0"},{"content":"rust에서 연산자 오버로드를 사용하려면 std::ops에 있는 trait을 상속 시키면 된다\n아레 코드는 Vec2끼리 더하기를 가능하게 하는 코드다\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 use std::ops::Add; struct Vec2 { x: f32, y: f32, } // Add 상속 impl Add for Vec2 { // 더했을때 반환할 타입 type Output = Vec2; /* let a = Vec2{x: 1.0, y: 3.0} let b = Vec2{x: 1.0, y: 3.0} 일 경우 a + b를 했을때 Vec2{ x: a.x + b.x, y: a.y + b.y, } 를 반환해주는 함수 */ fn add(self, rhs: Vec2) -\u0026gt; Vec2 { Vec2 { x: self.x + rhs.x, y: self.y + rhs.y, } } } 덧셈 말고도 뺄셈(Sub) 나눔셈(Div) 곱셈(Mul)같은게 있고 +=를 구현하고싶다면 AddAssign을 쓰면 된다\n","date":"2024-03-14T00:00:00Z","image":"https://blog.5-23.dev/p/rust-syntax-ops/thumb_hu4efc58c8e04c07399d2a263a5f4afac5_140728_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.5-23.dev/p/rust-syntax-ops/","title":"연산자 오버로드"}]